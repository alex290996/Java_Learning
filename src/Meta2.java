// Показать все аннотации для класса и метода
import java.lang.annotation.*;
import java.lang.reflect.*;

    @Retention(RetentionPolicy.RUNTIME)
    @interface MyAnno {
        String str() default "Тестирование";
        int val();}

    @Retention(RetentionPolicy.RUNTIME)
    @interface What {
        String description();}
        @What(description = "Аннотация тестового класса")
        @MyAnno(str = "Meta2", val = 99)
        class Meta2 {
            @What(description = "Аннотация тестового метода")
            @MyAnno(str = "Testing", val = 100)
            public static void myMeth() {
                Meta2 ob = new Meta2();
                try {
                    Annotation annos[] = ob.getClass().getAnnotations();
                    // вывести все аннотации для класса Meta2
                    System.out.println("Bce аннотации для класса Meta2:");
                    for (Annotation a : annos)
                        System.out.println(a);
                    System.out.println();
                    // вывести все аннотации для метода myMeth()
                    Method m = ob.getClass().getMethod("myMeth");
                    annos = m.getAnnotations();
                    System.out.println("Bce аннотации для метода myMeth() :");
                    for (Annotation a : annos)
                        System.out.println(a);
                } catch (NoSuchMethodException exc) {
                    System.out.println("Meтoд не найден.");
                }
            }
                public static void main (String args[]){
                    myMeth();
                }
            }

           /* Аннотация @Retention
            Предназначена для применения только в качестве аннотации к другим аннотациям. Она определяет правило удержания.

            Аннотация @Documented
            Служит маркерным интерфейсом, сообщающим инструментальному средству разработки, что аннотация
            должна быть документирована. Она предназначена для применения только в качестве аннотации к объявлению другой аннотации.

            Аннотация @Target
            Задает типы элементов, к которым можно применять аннотацию. Она предназначена для применения только в качестве
            аннотации к другим аннотациям. Аннотация @Target принимает один аргумент, который должен быть константой
            из перечисления ElementType.

            ANNOTATION_ТYPE - Другая аннотация
            CONSTRUCTOR - Конструктор
            FIELD - Поле
            LOCAL_VARIAВLE - Локальная переменная
            МЕТНОD - Метод
            РАСКАGЕ - Пакет
            PARAМETER - Параметр
            ТУРЕ - Класс, интерфейс или перечисление
            ТУРЕ_РАRАМЕТЕR - Параметр типа (добавлено в версии JDK 8)
            ТYPE_USE - Использование типа (добавлено в версии JDK 8)

             Аннотация @Inherited
             Это маркерная аннотация, которую можно применять только в другом объявлении аннотации. Более того, она
             оказывает воздействие только на те аннотации, которые будут применяться в объявлениях классов.
             Аннотация @Inherited обусловливает наследование аннотации из суперкласса в подклассе. Так, если конкретная
             аннотация запрашивается в подклассе, то в отсутствие этой аннотации в подклассе проверяется ее
             присутствие в суперклассе. Если запрашиваемая аннотация присутствует в суперклассе и аннотирована как
             @Inherited, то она будет возвращена по запросу.

             Аннотация@Оvеrridе
             Это маркерная аннотация, которую можно применять только в методах. Метод, аннотированный как @Override,
             должен переопределять метод из суперкласса.

             Аннотация @Deprecated
             Эта маркерная аннотация обозначает, что объявление устарело и должно быть заменено более новой формой.
             Начиная с версии JDK 9, аннотация @Deprecated позволяет также указать версию Java, с которой
             аннотируемый элемент считается не рекомендованным к употреблению и подлежит удалению.

             Аннотация @Functionalinterface
             Эта маркерная аннотация предназначена для применения в интерфейсах. Она обозначает, что аннотируемый
             интерфейс является функц,иональным, т.е. содержит один и только один абстрактный метод.
             Функциональные интерфейсы применяются в лямбда-выражениях.

             Аннотация @SuppressWarnings
             Эта аннотация обозначает, что следует подавить одно или несколько предупреждений, которые могут
             быть выданы компилятором. Подавляемые предупреждения указываются по имени в строковой форме.
                */